# ════════════════════════════════════════════════════════════════════════════════
# Simulate Error Rate - voting01 (Parallel Burst Mode)
#
# Sends PARALLEL traffic to the QA vote endpoint with a configurable % of
# requests carrying the X-Simulate-Error header, producing 500s captured by
# New Relic. Uses concurrent workers for high-throughput bursts that create
# visible spikes in NR dashboards within seconds.
# ════════════════════════════════════════════════════════════════════════════════
name: "Simulate Error Rate - voting01"

on:
  workflow_dispatch:
    inputs:
      error_rate:
        description: "Error rate percentage (0-100)"
        required: true
        default: "30"
        type: string
      total_requests:
        description: "Total number of requests to send"
        required: true
        default: "500"
        type: string
      concurrency:
        description: "Parallel workers (simultaneous requests)"
        required: true
        default: "20"
        type: string
      delay_ms:
        description: "Delay between batches in milliseconds (0 = max speed)"
        required: true
        default: "100"
        type: string
      environment:
        description: "Target environment"
        required: true
        default: "qa"
        type: choice
        options:
          - qa
          - staging
          - uat

jobs:
  simulate-errors:
    name: "Burst ${{ inputs.error_rate }}% errors → ${{ inputs.environment }} (${{ inputs.concurrency }} workers)"
    runs-on: ubuntu-latest
    steps:
      - name: Run parallel error simulation
        run: |
          set -euo pipefail

          # ── Configuration ──────────────────────────────────────────────
          ENV="${{ inputs.environment }}"
          BASE_URL="https://vote-voting01-${ENV}.agent.opsera.dev"
          ERROR_RATE=${{ inputs.error_rate }}
          TOTAL=${{ inputs.total_requests }}
          CONCURRENCY=${{ inputs.concurrency }}
          DELAY_SEC=$(echo "scale=3; ${{ inputs.delay_ms }} / 1000" | bc)

          echo "══════════════════════════════════════════════════════════"
          echo "  Error Rate Simulation - voting01 ${ENV} (BURST MODE)"
          echo "══════════════════════════════════════════════════════════"
          echo "  Target:      ${BASE_URL}"
          echo "  Error Rate:  ${ERROR_RATE}%"
          echo "  Requests:    ${TOTAL}"
          echo "  Concurrency: ${CONCURRENCY} parallel workers"
          echo "  Batch Delay: ${DELAY_SEC}s"
          echo "══════════════════════════════════════════════════════════"
          echo ""

          # ── Verify endpoint is reachable ────────────────────────────
          echo "→ Checking endpoint health..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${BASE_URL}/health" || echo "000")
          if [ "$HTTP_CODE" != "200" ]; then
            echo "✗ Health check failed (HTTP ${HTTP_CODE}). Is the ${ENV} environment running?"
            exit 1
          fi
          echo "✓ Endpoint healthy"
          echo ""

          # ── Create results directory ───────────────────────────────
          RESULTS_DIR=$(mktemp -d)

          # ── Worker function ────────────────────────────────────────
          # Each worker sends one request and logs the result to a file
          send_request() {
            local REQ_NUM=$1
            local RESULT_FILE="${RESULTS_DIR}/req_${REQ_NUM}"
            local RAND=$((RANDOM % 100))

            if [ "$RAND" -lt "$ERROR_RATE" ]; then
              # Error request
              CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 \
                -X POST \
                -H "X-Simulate-Error: true" \
                -d "vote=a" \
                "${BASE_URL}/" 2>/dev/null || echo "000")
              echo "ERR ${CODE}" > "$RESULT_FILE"
            else
              # Normal request
              CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 \
                -X POST \
                -d "vote=a" \
                "${BASE_URL}/" 2>/dev/null || echo "000")
              echo "OK ${CODE}" > "$RESULT_FILE"
            fi
          }
          export -f send_request
          export RESULTS_DIR BASE_URL ERROR_RATE

          # ── Send traffic in parallel batches ───────────────────────
          echo "→ Sending ${TOTAL} requests with ${CONCURRENCY} parallel workers..."
          echo ""

          START_TIME=$(date +%s)
          SENT=0

          while [ "$SENT" -lt "$TOTAL" ]; do
            # Calculate batch size (remaining or concurrency, whichever is smaller)
            REMAINING=$((TOTAL - SENT))
            BATCH_SIZE=$((REMAINING < CONCURRENCY ? REMAINING : CONCURRENCY))

            # Launch batch of parallel requests
            for j in $(seq 1 "$BATCH_SIZE"); do
              REQ_ID=$((SENT + j))
              send_request "$REQ_ID" &
            done

            # Wait for this batch to complete
            wait

            SENT=$((SENT + BATCH_SIZE))

            # Progress log every batch
            PCT=$((SENT * 100 / TOTAL))

            # Count results so far
            CURRENT_500=$(grep -l "500" "$RESULTS_DIR"/req_* 2>/dev/null | wc -l | tr -d ' ')
            echo "[${PCT}%] Sent ${SENT}/${TOTAL} | HTTP 500s so far: ${CURRENT_500}"

            # Small delay between batches (not between individual requests)
            if [ "$SENT" -lt "$TOTAL" ] && [ "$DELAY_SEC" != "0" ] && [ "$DELAY_SEC" != ".000" ]; then
              sleep "$DELAY_SEC"
            fi
          done

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))

          # ── Tally results ──────────────────────────────────────────
          HTTP_500=0
          HTTP_200=0
          HTTP_OTHER=0
          ERRORS_SENT=0
          NORMAL_SENT=0

          for f in "$RESULTS_DIR"/req_*; do
            LINE=$(cat "$f")
            TYPE=$(echo "$LINE" | cut -d' ' -f1)
            CODE=$(echo "$LINE" | cut -d' ' -f2)

            if [ "$TYPE" = "ERR" ]; then
              ERRORS_SENT=$((ERRORS_SENT + 1))
            else
              NORMAL_SENT=$((NORMAL_SENT + 1))
            fi

            if [ "$CODE" = "500" ]; then
              HTTP_500=$((HTTP_500 + 1))
            elif [ "$CODE" = "200" ]; then
              HTTP_200=$((HTTP_200 + 1))
            else
              HTTP_OTHER=$((HTTP_OTHER + 1))
            fi
          done

          ACTUAL_RATE=0
          if [ "$TOTAL" -gt 0 ]; then
            ACTUAL_RATE=$((HTTP_500 * 100 / TOTAL))
          fi

          RPS=$((TOTAL / (DURATION > 0 ? DURATION : 1)))

          echo ""
          echo "══════════════════════════════════════════════════════════"
          echo "  RESULTS"
          echo "══════════════════════════════════════════════════════════"
          echo "  Total requests:    ${TOTAL}"
          echo "  Error requests:    ${ERRORS_SENT} (with X-Simulate-Error header)"
          echo "  Normal requests:   ${NORMAL_SENT}"
          echo "  ──────────────────────────────────────────────────────"
          echo "  HTTP 200 (OK):     ${HTTP_200}"
          echo "  HTTP 500 (Error):  ${HTTP_500}"
          echo "  HTTP Other:        ${HTTP_OTHER}"
          echo "  ──────────────────────────────────────────────────────"
          echo "  Target error rate: ${ERROR_RATE}%"
          echo "  Actual error rate: ${ACTUAL_RATE}%"
          echo "  Duration:          ${DURATION}s"
          echo "  Throughput:        ~${RPS} req/s"
          echo "══════════════════════════════════════════════════════════"

          # Clean up
          rm -rf "$RESULTS_DIR"

          # Export for summary step
          echo "HTTP_500=${HTTP_500}" >> $GITHUB_ENV
          echo "ACTUAL_RATE=${ACTUAL_RATE}" >> $GITHUB_ENV
          echo "DURATION=${DURATION}" >> $GITHUB_ENV
          echo "RPS=${RPS}" >> $GITHUB_ENV

      - name: Summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ### Error Rate Simulation Results (Burst Mode)

          | Parameter | Value |
          |-----------|-------|
          | Environment | \`${{ inputs.environment }}\` |
          | Target Error Rate | ${{ inputs.error_rate }}% |
          | Total Requests | ${{ inputs.total_requests }} |
          | Concurrency | ${{ inputs.concurrency }} workers |
          | Batch Delay | ${{ inputs.delay_ms }}ms |
          | **HTTP 500s** | **${HTTP_500:-?}** |
          | **Actual Error Rate** | **${ACTUAL_RATE:-?}%** |
          | Duration | ${DURATION:-?}s |
          | Throughput | ~${RPS:-?} req/s |
          EOF
