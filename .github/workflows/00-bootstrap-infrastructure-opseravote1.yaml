# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BOOTSTRAP INFRASTRUCTURE - opseravote1
# Touchless: ECR â†’ Manifests â†’ ArgoCD
# Generated by Opsera Code-to-Cloud Enterprise v0.920
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "00-Bootstrap (opseravote1)"

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options: [apply, destroy]
        default: 'apply'
      runner:
        description: 'Runner type'
        type: choice
        options: ['github-hosted', 'self-hosted']
        default: 'github-hosted'

env:
  APP_NAME: opseravote1
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: Create ECR Repositories
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-ecr:
    name: "ðŸ“¦ Create ECR Repos"
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    if: inputs.action == 'apply'
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR Repositories
        run: |
          for SERVICE in vote result worker; do
            REPO="opsera/${{ env.APP_NAME }}-${SERVICE}"
            aws ecr describe-repositories --repository-names $REPO 2>/dev/null || \
            aws ecr create-repository --repository-name $REPO --image-scanning-configuration scanOnPush=true
            echo "âœ… ECR: $REPO" >> $GITHUB_STEP_SUMMARY
          done

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: Create Namespace & ECR Pull Secret
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-namespace:
    name: "ðŸ”§ Setup Namespace"
    needs: [create-ecr]
    if: inputs.action == 'apply'
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create Namespace
        run: |
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          kubectl get namespace $NS 2>/dev/null || kubectl create namespace $NS
          echo "âœ… Namespace: $NS" >> $GITHUB_STEP_SUMMARY

      - name: Create ECR Pull Secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="${ECR_TOKEN}" \
            --namespace="${NS}" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… ECR pull secret created" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: Update Manifests with ECR Registry
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ðŸ“ Update Manifests"
    needs: [create-ecr]
    if: inputs.action == 'apply'
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECR Registry
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          sed -i "s|PLACEHOLDER_ECR_REGISTRY|${ECR}|g" .opsera-opseravote1/k8s/overlays/dev/kustomization.yaml
          echo "âœ… ECR registry set: ${ECR}" >> $GITHUB_STEP_SUMMARY

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .opsera-opseravote1/
          git diff --cached --quiet || git commit -m "$(cat <<'EOF'
          bootstrap(opseravote1): Configure DEV manifests [skip ci]
          EOF
          )"
          git pull --rebase origin main
          git push origin main

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 4: Register Repository with ArgoCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  register-repo:
    name: "ðŸ”— Register Repo"
    needs: [update-manifests]
    if: inputs.action == 'apply'
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        run: aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create Repo Secret
        run: |
          kubectl get secret repo-${{ env.APP_NAME }} -n argocd 2>/dev/null || \
          kubectl create secret generic repo-${{ env.APP_NAME }} -n argocd \
            --from-literal=type=git \
            --from-literal=url="https://github.com/${{ github.repository }}.git" \
            --from-literal=password="${{ secrets.GH_PAT }}" \
            --from-literal=username="git"
          kubectl label secret repo-${{ env.APP_NAME }} -n argocd argocd.argoproj.io/secret-type=repository --overwrite
          echo "âœ… Repository registered with ArgoCD" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 5: Apply ArgoCD Application
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  apply-argocd:
    name: "ðŸš€ Apply ArgoCD"
    needs: [register-repo, setup-namespace]
    if: inputs.action == 'apply'
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        run: aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Apply ArgoCD App
        run: kubectl apply -f .opsera-opseravote1/argocd/dev/application.yaml

      - name: Trigger Sync
        run: |
          kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd argocd.argoproj.io/refresh=hard --overwrite
          echo "âœ… ArgoCD app applied and sync triggered" >> $GITHUB_STEP_SUMMARY

      - name: Wait for Sync
        run: |
          for i in {1..30}; do
            STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            echo "Sync: $STATUS"
            [ "$STATUS" == "Synced" ] && exit 0
            sleep 10
          done
          echo "âš ï¸ Sync still in progress"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 6: Summary
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“Š Summary"
    needs: [create-ecr, setup-namespace, update-manifests, register-repo, apply-argocd]
    if: always() && inputs.action == 'apply'
    runs-on: ${{ inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - name: Generate Summary
        run: |
          echo "# ðŸŽ‰ Bootstrap Complete: opseravote1" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Status" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ECR Repos | ${{ needs.create-ecr.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | ${{ needs.setup-namespace.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Manifests | ${{ needs.update-manifests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Repo Registration | ${{ needs.register-repo.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD | ${{ needs.apply-argocd.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Run CI workflow: \`gh workflow run ci-build-push-opseravote1-dev.yaml\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Access Vote: https://vote-opseravote1-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
          echo "3. Access Result: https://result-opseravote1-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
