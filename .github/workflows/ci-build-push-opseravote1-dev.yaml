# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI BUILD & DEPLOY - opseravote1 DEV
# Security: Gitleaks + Grype | Quality: SonarQube | Notify: Slack + Jira
# Generated by Opsera Code-to-Cloud Enterprise v0.920
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "CI Build (opseravote1-dev)"

on:
  workflow_dispatch:
    inputs:
      security_scan_mode:
        description: 'Security scan behavior'
        type: choice
        options: ['fail', 'warn', 'skip']
        default: 'warn'
      quality_gate_mode:
        description: 'Quality gate behavior'
        type: choice
        options: ['blocking', 'non-blocking', 'skip']
        default: 'non-blocking'
      notify_on:
        description: 'When to send notifications'
        type: choice
        options: ['always', 'failure', 'success', 'never']
        default: 'always'
      runner:
        description: 'Runner type'
        type: choice
        options: ['github-hosted', 'self-hosted']
        default: 'github-hosted'
  push:
    branches: [main]
    paths:
      - 'vote/**'
      - 'result/**'
      - 'worker/**'
      - '.opsera-opseravote1/**'

env:
  APP_NAME: opseravote1
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

permissions:
  contents: write
  security-events: write
  pull-requests: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: SECURITY SCANNING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  security-gitleaks:
    name: "ğŸ”’ Security Scan"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    if: github.event.inputs.security_scan_mode != 'skip'
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Security Scan Status
        run: |
          echo "### ğŸ”’ Security Scan" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Security scanning configured" >> $GITHUB_STEP_SUMMARY
          echo "Container scanning (Grype) runs during the build stage." >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: QUALITY GATES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quality-sonarqube:
    name: "ğŸ“Š SonarQube"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    if: github.event.inputs.quality_gate_mode != 'skip'
    continue-on-error: ${{ github.event.inputs.quality_gate_mode != 'blocking' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Check SonarQube Configuration
        id: check-sonar
        run: |
          if [ -n "${{ secrets.SONAR_TOKEN }}" ] && [ -n "${{ secrets.SONAR_HOST_URL }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ SonarQube secrets not configured - skipping scan" >> $GITHUB_STEP_SUMMARY
          fi
      - name: SonarQube Scan
        if: steps.check-sonar.outputs.configured == 'true'
        continue-on-error: true
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=opsera-opseravote1
            -Dsonar.projectName=opseravote1
            -Dsonar.sources=vote,result,worker

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: BUILD & PUSH (3 services)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build:
    name: "ğŸ—ï¸ Build & Push"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    needs: [security-gitleaks, quality-sonarqube]
    if: always() && !contains(needs.*.result, 'failure')
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Generate Tag
        id: tag
        run: |
          TAG="$(git rev-parse --short HEAD)-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "### ğŸ·ï¸ Image Tag: \`${TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Build, Scan & Push Vote
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-vote"
          docker build -f .opsera-opseravote1/Dockerfiles/Dockerfile.vote -t ${ECR}:${{ steps.tag.outputs.tag }} .
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Vote built & pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build, Scan & Push Result
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-result"
          docker build -f .opsera-opseravote1/Dockerfiles/Dockerfile.result -t ${ECR}:${{ steps.tag.outputs.tag }} .
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Result built & pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build, Scan & Push Worker
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-worker"
          docker build -f .opsera-opseravote1/Dockerfiles/Dockerfile.worker -t ${ECR}:${{ steps.tag.outputs.tag }} .
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Worker built & pushed" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: DEPLOY TO DEV
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: "ğŸš€ Deploy"
    needs: [build]
    if: always() && needs.build.result == 'success'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    outputs:
      success: ${{ steps.verify.outputs.success }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Update Kustomization
        run: |
          cd .opsera-opseravote1/k8s/overlays/${{ env.ENVIRONMENT }}
          sed -i "s|newTag:.*|newTag: ${{ needs.build.outputs.image_tag }}|g" kustomization.yaml

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .opsera-opseravote1/
          git diff --cached --quiet || git commit -m "$(cat <<'EOF'
          deploy(opseravote1-dev): ${{ needs.build.outputs.image_tag }} [skip ci]
          EOF
          )"
          git pull --rebase origin main
          git push origin main

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Refresh ECR Pull Secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" \
            --docker-username=AWS --docker-password="${ECR_TOKEN}" \
            --namespace="${NS}" --dry-run=client -o yaml | kubectl apply -f -

      - name: Trigger ArgoCD Sync
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd argocd.argoproj.io/refresh=hard --overwrite

      - name: Verify Deployment
        id: verify
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          for i in {1..40}; do
            VOTE=$(kubectl get deploy vote -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            RESULT=$(kubectl get deploy result -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            WORKER=$(kubectl get deploy worker -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            echo "Vote: ${VOTE:-0}, Result: ${RESULT:-0}, Worker: ${WORKER:-0}"
            if [ "${VOTE:-0}" -ge 1 ] && [ "${RESULT:-0}" -ge 1 ] && [ "${WORKER:-0}" -ge 1 ]; then
              echo "âœ… All services ready!" >> $GITHUB_STEP_SUMMARY
              echo "- Vote: https://vote-opseravote1-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
              echo "- Result: https://result-opseravote1-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 15
          done
          echo "success=false" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 5: NOTIFICATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify-slack:
    name: "ğŸ“¢ Slack Notification"
    needs: [security-gitleaks, quality-sonarqube, build, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check Slack Configuration
        id: check-slack
        run: |
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Slack webhook not configured" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send Notification
        if: steps.check-slack.outputs.configured == 'true'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "${{ needs.deploy.outputs.success == 'true' && 'âœ…' || 'âŒ' }} opseravote1-dev deployment ${{ needs.deploy.outputs.success == 'true' && 'succeeded' || 'failed' }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {"type": "plain_text", "text": "${{ needs.deploy.outputs.success == 'true' && 'âœ… DEV Deployment Succeeded' || 'âŒ DEV Deployment Failed' }}"}
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*App:*\n`opseravote1`"},
                    {"type": "mrkdwn", "text": "*Env:*\n`dev`"},
                    {"type": "mrkdwn", "text": "*Tag:*\n`${{ needs.build.outputs.image_tag }}`"},
                    {"type": "mrkdwn", "text": "*By:*\n${{ github.actor }}"}
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {"type": "button", "text": {"type": "plain_text", "text": "View Workflow"}, "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"},
                    {"type": "button", "text": {"type": "plain_text", "text": "Vote App"}, "url": "https://vote-opseravote1-dev.agent.opsera.dev"},
                    {"type": "button", "text": {"type": "plain_text", "text": "Result App"}, "url": "https://result-opseravote1-dev.agent.opsera.dev"}
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 6: DEPLOYMENT LANDSCAPE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  trigger-landscape:
    name: "ğŸŒ Landscape Update"
    needs: [deploy]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Landscape Update
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'deployment-landscape-opseravote1.yaml',
                ref: 'main'
              })
              core.summary.addRaw('âœ… Landscape update triggered')
              await core.summary.write()
            } catch (e) {
              core.warning('Landscape workflow not found or failed to trigger: ' + e.message)
            }
