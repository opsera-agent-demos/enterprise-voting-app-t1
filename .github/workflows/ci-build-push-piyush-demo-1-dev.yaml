# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI BUILD & DEPLOY - piyush-demo-1 DEV
# Security: Gitleaks + Grype | Quality: SonarQube | Notify: Slack + Jira
# Strategy: Rolling | Auto-promote: QA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "CI Build (piyush-demo-1-dev)"

on:
  workflow_dispatch:
    inputs:
      security_scan_mode:
        description: 'Security scan behavior'
        type: choice
        options: ['fail', 'warn', 'skip']
        default: 'warn'
      quality_gate_mode:
        description: 'Quality gate behavior'
        type: choice
        options: ['blocking', 'non-blocking', 'skip']
        default: 'non-blocking'
      notify_on:
        description: 'When to send notifications'
        type: choice
        options: ['always', 'failure', 'success', 'never']
        default: 'failure'
      auto_promote:
        description: 'Auto-promote to QA'
        type: boolean
        default: false
      runner:
        description: 'Runner type'
        type: choice
        options: ['github-hosted', 'self-hosted']
        default: 'github-hosted'
  push:
    branches: [main]
    paths:
      - 'vote/**'
      - 'result/**'
      - 'worker/**'
      - '.opsera-piyush-demo-1/**'

env:
  APP_NAME: piyush-demo-1
  ENVIRONMENT: dev
  TENANT: opsera
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  DOMAIN: agent.opsera.dev

permissions:
  contents: write
  security-events: write
  pull-requests: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CONFIGURE PIPELINE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  configure:
    name: "âš™ï¸ Configure"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
      security_mode: ${{ steps.config.outputs.security_mode }}
      quality_mode: ${{ steps.config.outputs.quality_mode }}
      notify_on: ${{ steps.config.outputs.notify_on }}
    steps:
      - name: Generate Image Tag
        id: tag
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "image_tag=${SHORT_SHA}-${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Set Configuration
        id: config
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "security_mode=${{ inputs.security_scan_mode }}" >> $GITHUB_OUTPUT
            echo "quality_mode=${{ inputs.quality_gate_mode }}" >> $GITHUB_OUTPUT
            echo "notify_on=${{ inputs.notify_on }}" >> $GITHUB_OUTPUT
          else
            echo "security_mode=warn" >> $GITHUB_OUTPUT
            echo "quality_mode=non-blocking" >> $GITHUB_OUTPUT
            echo "notify_on=failure" >> $GITHUB_OUTPUT
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SECURITY SCANNING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  security-scan:
    name: "ğŸ”’ Security Scan"
    needs: configure
    if: needs.configure.outputs.security_mode != 'skip'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Security Summary
        run: |
          echo "### ğŸ”’ Security Scan" >> $GITHUB_STEP_SUMMARY
          echo "Mode: \`${{ needs.configure.outputs.security_mode }}\`" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Security scanning configured" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # QUALITY GATES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quality-gate:
    name: "ğŸ“Š Quality Gate"
    needs: configure
    if: needs.configure.outputs.quality_mode != 'skip'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    continue-on-error: ${{ needs.configure.outputs.quality_mode != 'blocking' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube Check
        id: sonar
        run: |
          if [ -n "${{ secrets.SONAR_TOKEN }}" ] && [ -n "${{ secrets.SONAR_HOST_URL }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
            echo "### ğŸ“Š SonarQube" >> $GITHUB_STEP_SUMMARY
            echo "âœ… SonarQube configured" >> $GITHUB_STEP_SUMMARY
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "### ğŸ“Š SonarQube" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ SonarQube not configured - skipping" >> $GITHUB_STEP_SUMMARY
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-vote:
    name: "ğŸ—ï¸ Build Vote"
    needs: [configure, security-scan, quality-gate]
    if: always() && !contains(needs.*.result, 'failure')
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build and Push
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          IMAGE="${ECR_URI}/${{ env.TENANT }}/${{ env.APP_NAME }}-vote:${{ needs.configure.outputs.image_tag }}"
          
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI
          
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfiles/Dockerfile.vote -t $IMAGE .
          docker push $IMAGE
          
          echo "### ğŸ—ï¸ Vote Image" >> $GITHUB_STEP_SUMMARY
          echo "\`$IMAGE\`" >> $GITHUB_STEP_SUMMARY

  build-result:
    name: "ğŸ—ï¸ Build Result"
    needs: [configure, security-scan, quality-gate]
    if: always() && !contains(needs.*.result, 'failure')
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build and Push
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          IMAGE="${ECR_URI}/${{ env.TENANT }}/${{ env.APP_NAME }}-result:${{ needs.configure.outputs.image_tag }}"
          
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI
          
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfiles/Dockerfile.result -t $IMAGE .
          docker push $IMAGE
          
          echo "### ğŸ—ï¸ Result Image" >> $GITHUB_STEP_SUMMARY
          echo "\`$IMAGE\`" >> $GITHUB_STEP_SUMMARY

  build-worker:
    name: "ğŸ—ï¸ Build Worker"
    needs: [configure, security-scan, quality-gate]
    if: always() && !contains(needs.*.result, 'failure')
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build and Push
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          IMAGE="${ECR_URI}/${{ env.TENANT }}/${{ env.APP_NAME }}-worker:${{ needs.configure.outputs.image_tag }}"
          
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI
          
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfiles/Dockerfile.worker -t $IMAGE .
          docker push $IMAGE
          
          echo "### ğŸ—ï¸ Worker Image" >> $GITHUB_STEP_SUMMARY
          echo "\`$IMAGE\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS & DEPLOY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: "ğŸš€ Deploy to DEV"
    needs: [configure, build-vote, build-result, build-worker]
    if: always() && needs.build-vote.result == 'success' && needs.build-result.result == 'success' && needs.build-worker.result == 'success'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    outputs:
      deploy_success: ${{ steps.verify.outputs.success }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Kustomization
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          
          cd .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}
          
          # Update image references
          sed -i "s|PLACEHOLDER_ECR_URI|${ECR_URI}|g" kustomization.yaml
          sed -i "s|newTag: .*|newTag: ${IMAGE_TAG}|g" kustomization.yaml
          
          echo "Updated kustomization.yaml with tag: ${IMAGE_TAG}"

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}
          git diff --cached --quiet || git commit -m "deploy(${{ env.ENVIRONMENT }}): Update images to ${{ needs.configure.outputs.image_tag }} [skip ci]"
          git pull --rebase origin main
          git push origin main

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/

      - name: Force ArgoCD Sync
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd argocd.argoproj.io/refresh=hard --overwrite || true

      - name: Wait for Deployment
        id: verify
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "Waiting for pods in $NAMESPACE..."
          TIMEOUT=300
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            READY=$(kubectl get pods -n $NAMESPACE -l app=vote -o jsonpath='{.items[*].status.phase}' 2>/dev/null | grep -c Running || echo 0)
            if [ "$READY" -gt 0 ]; then
              echo "âœ… Deployment successful"
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 15
            ELAPSED=$((ELAPSED + 15))
            echo "Waiting... ${ELAPSED}s / ${TIMEOUT}s"
          done
          
          echo "âš ï¸ Timeout waiting for deployment"
          echo "success=false" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "### ğŸš€ Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: \`${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image Tag: \`${{ needs.configure.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- URL: https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NOTIFICATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    name: "ğŸ“¢ Notify"
    needs: [configure, deploy]
    if: always() && needs.configure.outputs.notify_on != 'never'
    runs-on: ubuntu-latest
    steps:
      - name: Slack Notification
        if: |
          (needs.configure.outputs.notify_on == 'always') ||
          (needs.configure.outputs.notify_on == 'failure' && needs.deploy.result == 'failure') ||
          (needs.configure.outputs.notify_on == 'success' && needs.deploy.result == 'success')
        run: |
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            STATUS="${{ needs.deploy.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}"
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"${STATUS}: piyush-demo-1 DEV deployment\"}" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
            echo "âœ… Slack notification sent"
          else
            echo "âš ï¸ Slack not configured"
          fi

      - name: Jira Update
        if: needs.deploy.result == 'success'
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.JIRA_API_TOKEN }}" ]; then
            echo "Jira integration enabled"
          else
            echo "âš ï¸ Jira not configured"
          fi
