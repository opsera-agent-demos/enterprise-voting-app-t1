# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NEXT-GENERATION DEPLOYMENT LANDSCAPE REPORT - voting01
# Visual dashboard with architecture diagrams, hyperlinks, and status badges
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ğŸ“Š Landscape (voting01)"

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'
  push:
    branches: [main]
    paths:
      - '.opsera-voting01/k8s/overlays/*/kustomization.yaml'

env:
  APP_NAME: voting01
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  GITHUB_REPO: opsera-agentic/enterprise-voting-demo-only

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # COLLECT DATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  collect-data:
    name: "ğŸ“¦ Collect Data"
    runs-on: ubuntu-latest
    outputs:
      dev_version: ${{ steps.versions.outputs.dev }}
      qa_version: ${{ steps.versions.outputs.qa }}
      staging_version: ${{ steps.versions.outputs.staging }}
      uat_version: ${{ steps.versions.outputs.uat }}
      mock1_version: ${{ steps.versions.outputs.mock1 }}
      sbx1_version: ${{ steps.versions.outputs.sbx1 }}
      in_sync: ${{ steps.versions.outputs.in_sync }}
      dev_history: ${{ steps.history.outputs.dev_history }}
      qa_history: ${{ steps.history.outputs.qa_history }}
      staging_history: ${{ steps.history.outputs.staging_history }}
      uat_history: ${{ steps.history.outputs.uat_history }}
      mock1_history: ${{ steps.history.outputs.mock1_history }}
      sbx1_history: ${{ steps.history.outputs.sbx1_history }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract Versions
        id: versions
        run: |
          DEV=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/dev/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")
          QA=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/qa/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")
          STAGING=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/staging/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")
          UAT=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/uat/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")
          MOCK1=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/mock1/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")
          SBX1=$(grep -A2 'PLACEHOLDER_VOTE' .opsera-voting01/k8s/overlays/sbx1/kustomization.yaml | grep newTag | awk '{print $2}' || echo "unknown")

          echo "dev=${DEV}" >> $GITHUB_OUTPUT
          echo "qa=${QA}" >> $GITHUB_OUTPUT
          echo "staging=${STAGING}" >> $GITHUB_OUTPUT
          echo "uat=${UAT}" >> $GITHUB_OUTPUT
          echo "mock1=${MOCK1}" >> $GITHUB_OUTPUT
          echo "sbx1=${SBX1}" >> $GITHUB_OUTPUT

          if [ "$DEV" == "$QA" ] && [ "$QA" == "$STAGING" ]; then
            echo "in_sync=true" >> $GITHUB_OUTPUT
          else
            echo "in_sync=false" >> $GITHUB_OUTPUT
          fi

      - name: Collect Deployment History
        id: history
        run: |
          # Function to get deployment history for an environment
          # Format: SHA~TAG~TIMESTAMP~AUTHOR (uses ~ as field separator, ; as record separator)
          # Note: AUTHOR is looked up from the source commit (extracted from image tag)
          #       to show the actual code author, not github-actions[bot]
          get_history() {
            local env=$1
            git log --oneline --grep="deploy(voting01-${env}):" --format="%H|%s|%ct|%an" -n 5 2>/dev/null | while read line; do
              if [ -n "$line" ]; then
                SHA=$(echo "$line" | cut -d'|' -f1)
                SHORT_SHA=$(echo "$SHA" | cut -c1-7)
                MSG=$(echo "$line" | cut -d'|' -f2 | sed 's/deploy(voting01-'${env}'): //' | sed 's/ \[skip ci\]//')
                TIMESTAMP=$(echo "$line" | cut -d'|' -f3)

                # Extract source commit SHA from image tag (format: sha-timestamp, e.g., f6487b9-20260203191222)
                SOURCE_SHA=$(echo "$MSG" | cut -d'-' -f1)

                # Look up the actual author of the source commit
                # If it's a bot commit, find the last human author
                AUTHOR=$(git log -1 --format="%an" "$SOURCE_SHA" 2>/dev/null || echo "Unknown")

                # If author is a bot, find the last non-bot commit author
                if [ "$AUTHOR" = "github-actions[bot]" ] || [ "$AUTHOR" = "GitHub Actions" ]; then
                  # Find the last commit by a human (not bot) before or at this SHA
                  AUTHOR=$(git log --format="%an" "$SOURCE_SHA" 2>/dev/null | grep -v -E "github-actions|GitHub Actions|\[bot\]" | head -1 || true)
                  [ -z "$AUTHOR" ] && AUTHOR=$(git log --format="%an" -10 2>/dev/null | grep -v -E "github-actions|GitHub Actions|\[bot\]" | head -1 || true)
                  [ -z "$AUTHOR" ] && AUTHOR="Unknown"
                fi

                echo "${SHORT_SHA}~${MSG}~${TIMESTAMP}~${AUTHOR}"
              fi
            done | tr '\n' ';' | sed 's/;$//'
          }

          DEV_HIST=$(get_history "dev")
          QA_HIST=$(get_history "qa")
          STAGING_HIST=$(get_history "staging")
          UAT_HIST=$(get_history "uat")
          MOCK1_HIST=$(get_history "mock1")
          SBX1_HIST=$(get_history "sbx1")

          echo "dev_history=${DEV_HIST}" >> $GITHUB_OUTPUT
          echo "qa_history=${QA_HIST}" >> $GITHUB_OUTPUT
          echo "staging_history=${STAGING_HIST}" >> $GITHUB_OUTPUT
          echo "uat_history=${UAT_HIST}" >> $GITHUB_OUTPUT
          echo "mock1_history=${MOCK1_HIST}" >> $GITHUB_OUTPUT
          echo "sbx1_history=${SBX1_HIST}" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # COLLECT CLUSTER METRICS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  collect-metrics:
    name: "ğŸ“Š Collect Metrics"
    runs-on: ubuntu-latest
    outputs:
      dev_pods: ${{ steps.metrics.outputs.dev_pods }}
      qa_pods: ${{ steps.metrics.outputs.qa_pods }}
      staging_pods: ${{ steps.metrics.outputs.staging_pods }}
      uat_pods: ${{ steps.metrics.outputs.uat_pods }}
      mock1_pods: ${{ steps.metrics.outputs.mock1_pods }}
      sbx1_pods: ${{ steps.metrics.outputs.sbx1_pods }}
      dev_health: ${{ steps.metrics.outputs.dev_health }}
      qa_health: ${{ steps.metrics.outputs.qa_health }}
      staging_health: ${{ steps.metrics.outputs.staging_health }}
      uat_health: ${{ steps.metrics.outputs.uat_health }}
      mock1_health: ${{ steps.metrics.outputs.mock1_health }}
      sbx1_health: ${{ steps.metrics.outputs.sbx1_health }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Get Cluster Metrics
        id: metrics
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} 2>/dev/null || true

          for ENV in dev qa staging uat mock1 sbx1; do
            NS="${{ env.APP_NAME }}-${ENV}"
            PODS=$(kubectl get pods -n $NS --no-headers 2>/dev/null | grep Running | wc -l | tr -d ' ')
            READY=$(kubectl get pods -n $NS --no-headers 2>/dev/null | grep -E "1/1|2/2|3/3" | wc -l | tr -d ' ')
            PODS=${PODS:-0}
            READY=${READY:-0}
            echo "${ENV}_pods=${PODS}" >> $GITHUB_OUTPUT
            if [ "$PODS" -gt 0 ] && [ "$READY" -eq "$PODS" ]; then
              echo "${ENV}_health=healthy" >> $GITHUB_OUTPUT
            elif [ "$PODS" -gt 0 ]; then
              echo "${ENV}_health=degraded" >> $GITHUB_OUTPUT
            else
              echo "${ENV}_health=unknown" >> $GITHUB_OUTPUT
            fi
          done

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # COLLECT LAST DEPLOY STATUS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  collect-workflow-status:
    name: "ğŸ”„ Workflow Status"
    runs-on: ubuntu-latest
    outputs:
      dev_status: ${{ steps.status.outputs.dev_status }}
      dev_jobs: ${{ steps.status.outputs.dev_jobs }}
      dev_run_id: ${{ steps.status.outputs.dev_run_id }}
      dev_has_failures: ${{ steps.status.outputs.dev_has_failures }}
      qa_status: ${{ steps.status.outputs.qa_status }}
      qa_jobs: ${{ steps.status.outputs.qa_jobs }}
      staging_status: ${{ steps.status.outputs.staging_status }}
      staging_jobs: ${{ steps.status.outputs.staging_jobs }}
    steps:
      - name: Get Last Workflow Runs
        id: status
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Function to get workflow status and jobs
          get_workflow_status() {
            local workflow=$1
            local env_name=$2

            # Get the last completed run
            RUN=$(gh api repos/${{ env.GITHUB_REPO }}/actions/workflows/${workflow}/runs \
              --jq '.workflow_runs | map(select(.status == "completed")) | .[0]' 2>/dev/null || echo "{}")

            if [ "$RUN" = "{}" ] || [ -z "$RUN" ] || [ "$RUN" = "null" ]; then
              echo "${env_name}_status=unknown" >> $GITHUB_OUTPUT
              echo "${env_name}_jobs=" >> $GITHUB_OUTPUT
              echo "${env_name}_run_id=" >> $GITHUB_OUTPUT
              echo "${env_name}_has_failures=false" >> $GITHUB_OUTPUT
              return
            fi

            RUN_ID=$(echo "$RUN" | jq -r '.id')
            CONCLUSION=$(echo "$RUN" | jq -r '.conclusion')

            echo "${env_name}_status=${CONCLUSION}" >> $GITHUB_OUTPUT
            echo "${env_name}_run_id=${RUN_ID}" >> $GITHUB_OUTPUT

            # Get job details
            JOBS=$(gh api repos/${{ env.GITHUB_REPO }}/actions/runs/${RUN_ID}/jobs \
              --jq '[.jobs[] | {name: .name, status: .conclusion, duration: ((.completed_at | fromdateiso8601) - (.started_at | fromdateiso8601))}]' 2>/dev/null || echo "[]")

            # Encode jobs as base64 to preserve JSON structure
            JOBS_B64=$(echo "$JOBS" | base64 -w 0)
            echo "${env_name}_jobs=${JOBS_B64}" >> $GITHUB_OUTPUT

            # Check for failures
            HAS_FAILURES=$(echo "$JOBS" | jq 'any(.[]; .status == "failure")')
            echo "${env_name}_has_failures=${HAS_FAILURES}" >> $GITHUB_OUTPUT
          }

          get_workflow_status "ci-build-push-voting01-dev.yaml" "dev"
          get_workflow_status "ci-build-push-voting01-qa.yaml" "qa"
          get_workflow_status "ci-build-push-voting01-staging.yaml" "staging"
          get_workflow_status "ci-build-push-voting01-uat.yaml" "uat"
          get_workflow_status "ci-build-push-voting01-mock1.yaml" "mock1"
          get_workflow_status "ci-build-push-voting01-sbx1.yaml" "sbx1"

      - name: Create Jira Ticket on Failure
        if: steps.status.outputs.dev_has_failures == 'true'
        continue-on-error: true
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
        run: |
          if [ -z "$JIRA_API_TOKEN" ] || [ -z "$JIRA_BASE_URL" ]; then
            echo "âš ï¸ Jira not configured - skipping ticket creation"
            exit 0
          fi

          RUN_ID="${{ steps.status.outputs.dev_run_id }}"
          RUN_URL="https://github.com/${{ env.GITHUB_REPO }}/actions/runs/${RUN_ID}"

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Basic $(echo -n "${JIRA_EMAIL}:${JIRA_API_TOKEN}" | base64)" \
            -H "Content-Type: application/json" \
            "${JIRA_BASE_URL}/rest/api/3/issue" \
            -d '{
              "fields": {
                "project": {"key": "DEPLOY"},
                "summary": "[voting01-dev] CI/CD Pipeline Failure",
                "description": {
                  "type": "doc",
                  "version": 1,
                  "content": [
                    {
                      "type": "paragraph",
                      "content": [
                        {"type": "text", "text": "The DEV pipeline has failed. Please investigate."}
                      ]
                    },
                    {
                      "type": "paragraph",
                      "content": [
                        {"type": "text", "text": "Workflow Run: "},
                        {"type": "text", "text": "'"${RUN_URL}"'", "marks": [{"type": "link", "attrs": {"href": "'"${RUN_URL}"'"}}]}
                      ]
                    }
                  ]
                },
                "issuetype": {"name": "Bug"},
                "priority": {"name": "High"},
                "labels": ["pipeline-failure", "voting01", "dev", "auto-created"]
              }
            }')

          ISSUE_KEY=$(echo "$RESPONSE" | jq -r '.key // "FAILED"')
          if [ "$ISSUE_KEY" != "FAILED" ] && [ "$ISSUE_KEY" != "null" ]; then
            echo "âœ… Created Jira ticket: ${ISSUE_KEY}" >> $GITHUB_STEP_SUMMARY
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # GENERATE REPORT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  generate-report:
    name: "ğŸ“Š Generate Report"
    needs: [collect-data, collect-metrics, collect-workflow-status]
    runs-on: ubuntu-latest
    steps:
      - name: Report Header
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          <div align="center">

          # ğŸš€ DEPLOYMENT LANDSCAPE
          ### voting01 | Enterprise Voting Application

          </div>

          ---

          EOF

      - name: Latest Deployments
        env:
          DEV_HIST: ${{ needs.collect-data.outputs.dev_history }}
          QA_HIST: ${{ needs.collect-data.outputs.qa_history }}
          STG_HIST: ${{ needs.collect-data.outputs.staging_history }}
          UAT_HIST: ${{ needs.collect-data.outputs.uat_history }}
          MOCK1_HIST: ${{ needs.collect-data.outputs.mock1_history }}
          SBX1_HIST: ${{ needs.collect-data.outputs.sbx1_history }}
          DEV_V: ${{ needs.collect-data.outputs.dev_version }}
          QA_V: ${{ needs.collect-data.outputs.qa_version }}
          STG_V: ${{ needs.collect-data.outputs.staging_version }}
          UAT_V: ${{ needs.collect-data.outputs.uat_version }}
          MOCK1_V: ${{ needs.collect-data.outputs.mock1_version }}
          SBX1_V: ${{ needs.collect-data.outputs.sbx1_version }}
          DEV_H: ${{ needs.collect-metrics.outputs.dev_health }}
          QA_H: ${{ needs.collect-metrics.outputs.qa_health }}
          STG_H: ${{ needs.collect-metrics.outputs.staging_health }}
          UAT_H: ${{ needs.collect-metrics.outputs.uat_health }}
          MOCK1_H: ${{ needs.collect-metrics.outputs.mock1_health }}
          SBX1_H: ${{ needs.collect-metrics.outputs.sbx1_health }}
          DEV_P: ${{ needs.collect-metrics.outputs.dev_pods }}
          QA_P: ${{ needs.collect-metrics.outputs.qa_pods }}
          STG_P: ${{ needs.collect-metrics.outputs.staging_pods }}
          UAT_P: ${{ needs.collect-metrics.outputs.uat_pods }}
          MOCK1_P: ${{ needs.collect-metrics.outputs.mock1_pods }}
          SBX1_P: ${{ needs.collect-metrics.outputs.sbx1_pods }}
          DEV_STATUS: ${{ needs.collect-workflow-status.outputs.dev_status }}
          DEV_RUN_ID: ${{ needs.collect-workflow-status.outputs.dev_run_id }}
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          echo "## ğŸš€ Latest Deployments" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Function to convert timestamp to relative time (mins/hours)
          relative_time() {
            local timestamp=$1
            local now=$(date +%s)
            local diff=$((now - timestamp))

            if [ $diff -lt 60 ]; then
              echo "just now"
            elif [ $diff -lt 3600 ]; then
              local mins=$((diff / 60))
              [ $mins -eq 1 ] && echo "1 min ago" || echo "${mins} mins ago"
            elif [ $diff -lt 86400 ]; then
              local hrs=$((diff / 3600))
              local remaining_mins=$(((diff % 3600) / 60))
              if [ $remaining_mins -gt 0 ]; then
                echo "${hrs}h ${remaining_mins}m ago"
              else
                [ $hrs -eq 1 ] && echo "1 hr ago" || echo "${hrs} hrs ago"
              fi
            elif [ $diff -lt 604800 ]; then
              local days=$((diff / 86400))
              [ $days -eq 1 ] && echo "1 day ago" || echo "${days} days ago"
            else
              local weeks=$((diff / 604800))
              [ $weeks -eq 1 ] && echo "1 week ago" || echo "${weeks} weeks ago"
            fi
          }

          # Health icon
          health_icon() {
            case "$1" in
              healthy) echo "âœ…" ;;
              degraded) echo "âš ï¸" ;;
              *) echo "â“" ;;
            esac
          }

          # Get latest deploy info for each environment
          get_latest() {
            local history=$1
            if [ -n "$history" ]; then
              echo "$history" | cut -d';' -f1
            fi
          }

          # Environment summary table
          echo "| Environment | Version | Health | Pods | Last Deploy | Deployed By |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|---------|--------|------|-------------|-------------|" >> $GITHUB_STEP_SUMMARY

          for ENV in DEV QA STAGING UAT MOCK1 SBX1; do
            case $ENV in
              DEV) HIST="$DEV_HIST"; VER="$DEV_V"; HEALTH="$DEV_H"; PODS="$DEV_P"; ICON="ğŸ”§" ;;
              QA) HIST="$QA_HIST"; VER="$QA_V"; HEALTH="$QA_H"; PODS="$QA_P"; ICON="ğŸ§ª" ;;
              STAGING) HIST="$STG_HIST"; VER="$STG_V"; HEALTH="$STG_H"; PODS="$STG_P"; ICON="ğŸ­" ;;
              UAT) HIST="$UAT_HIST"; VER="$UAT_V"; HEALTH="$UAT_H"; PODS="$UAT_P"; ICON="ğŸ”¬" ;;
              MOCK1) HIST="$MOCK1_HIST"; VER="$MOCK1_V"; HEALTH="$MOCK1_H"; PODS="$MOCK1_P"; ICON="ğŸ§©" ;;
              SBX1) HIST="$SBX1_HIST"; VER="$SBX1_V"; HEALTH="$SBX1_H"; PODS="$SBX1_P"; ICON="ğŸ–ï¸" ;;
            esac

            LATEST=$(get_latest "$HIST")
            if [ -n "$LATEST" ]; then
              TIMESTAMP=$(echo "$LATEST" | cut -d'~' -f3)
              AUTHOR=$(echo "$LATEST" | cut -d'~' -f4)
              REL_TIME=$(relative_time "$TIMESTAMP")
            else
              REL_TIME="-"
              AUTHOR="-"
            fi

            # Version link
            if [ "$VER" != "unknown" ] && [ -n "$VER" ]; then
              SHA=$(echo "$VER" | cut -d'-' -f1)
              VER_LINK="[\`${VER:0:20}\`](${REPO_URL}/commit/${SHA})"
            else
              VER_LINK="\`${VER}\`"
            fi

            echo "| ${ICON} **${ENV}** | ${VER_LINK} | $(health_icon $HEALTH) | ${PODS:-0} | ${REL_TIME} | ${AUTHOR} |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY

          # Pipeline status for DEV
          if [ -n "$DEV_RUN_ID" ] && [ "$DEV_STATUS" != "unknown" ]; then
            if [ "$DEV_STATUS" = "success" ]; then
              echo "> âœ… **Last DEV Pipeline:** Success - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            elif [ "$DEV_STATUS" = "failure" ]; then
              echo "> âŒ **Last DEV Pipeline:** Failed - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            else
              echo "> âš ï¸ **Last DEV Pipeline:** ${DEV_STATUS} - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Sync Status Banner
        env:
          IN_SYNC: ${{ needs.collect-data.outputs.in_sync }}
          VERSION: ${{ needs.collect-data.outputs.dev_version }}
        run: |
          if [ "$IN_SYNC" == "true" ]; then
            echo "> âœ… **ALL ENVIRONMENTS SYNCHRONIZED** - Version \`${VERSION}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "> âš ï¸ **ENVIRONMENTS OUT OF SYNC** - Review versions below" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Last Deploy Status
        env:
          DEV_STATUS: ${{ needs.collect-workflow-status.outputs.dev_status }}
          DEV_JOBS: ${{ needs.collect-workflow-status.outputs.dev_jobs }}
          DEV_RUN_ID: ${{ needs.collect-workflow-status.outputs.dev_run_id }}
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          echo "## ğŸš¦ Last DEV Deploy Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -z "$DEV_JOBS" ] || [ "$DEV_STATUS" = "unknown" ]; then
            echo "> â„¹ï¸ No recent deployment data available" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          else
            # Status icon
            if [ "$DEV_STATUS" = "success" ]; then
              echo "> âœ… **Pipeline Succeeded** - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            elif [ "$DEV_STATUS" = "failure" ]; then
              echo "> âŒ **Pipeline Failed** - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            else
              echo "> âš ï¸ **Pipeline ${DEV_STATUS}** - [View Run](${REPO_URL}/actions/runs/${DEV_RUN_ID})" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY

            # Decode and parse jobs
            JOBS_JSON=$(echo "$DEV_JOBS" | base64 -d 2>/dev/null || echo "[]")

            # Generate visual pipeline
            cat << 'MERMAID' >> $GITHUB_STEP_SUMMARY
          ```mermaid
          flowchart LR
              subgraph SCAN["Security & Quality"]
                  SEC["ğŸ”’ Security Scan"]
                  SONAR["ğŸ“Š SonarQube"]
              end
              BUILD["ğŸ—ï¸ Build & Push"]
              DEPLOY["ğŸš€ Deploy"]
              subgraph NOTIFY["Post-Deploy"]
                  JIRA_SEC["ğŸ”’ Jira Security"]
                  JIRA["ğŸ“‹ Jira Issue"]
                  SLACK["ğŸ“¢ Slack"]
              end

              SCAN --> BUILD --> DEPLOY --> NOTIFY
          ```
          MERMAID

            # Job status table
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Job | Status | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|--------|----------|" >> $GITHUB_STEP_SUMMARY

            echo "$JOBS_JSON" | jq -r '.[] | "\(.name)|\(.status)|\(.duration)"' 2>/dev/null | while IFS='|' read -r name status duration; do
              # Format duration
              if [ -n "$duration" ] && [ "$duration" != "null" ]; then
                if [ "$duration" -ge 60 ]; then
                  mins=$((duration / 60))
                  secs=$((duration % 60))
                  dur_str="${mins}m ${secs}s"
                else
                  dur_str="${duration}s"
                fi
              else
                dur_str="-"
              fi

              # Status icon
              case "$status" in
                success) icon="âœ…" ;;
                failure) icon="âŒ" ;;
                skipped) icon="â­ï¸" ;;
                *) icon="âšª" ;;
              esac

              echo "| ${name} | ${icon} ${status} | ${dur_str} |" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Application Architecture
        env:
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          cat << 'MERMAID' >> $GITHUB_STEP_SUMMARY
          ## ğŸ—³ï¸ Application Architecture

          ```mermaid
          flowchart TB
              subgraph FRONTEND["Frontend Layer"]
                  VOTE["ğŸ—³ï¸ Vote<br/>Python Flask<br/>Port 80"]
                  RESULT["ğŸ“Š Result<br/>Node.js + Socket.io<br/>Port 80"]
              end

              subgraph BACKEND["Backend Layer"]
                  WORKER["âš™ï¸ Worker<br/>.NET Core<br/>Background Process"]
              end

              subgraph DATA["Data Layer"]
                  REDIS[("ğŸ”´ Redis<br/>Vote Queue<br/>ElastiCache")]
                  POSTGRES[("ğŸ˜ PostgreSQL<br/>Vote Storage<br/>RDS")]
              end

              USER((ğŸ‘¤ User)) --> VOTE
              USER --> RESULT
              VOTE -->|"Submit Vote"| REDIS
              WORKER -->|"Read Votes"| REDIS
              WORKER -->|"Persist Votes"| POSTGRES
              RESULT -->|"Query Results"| POSTGRES
          ```

          ### Service Details
          MERMAID
          echo "| Service | Language | Source | Dockerfile | Purpose |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|----------|--------|------------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ—³ï¸ Vote | Python 3.9 | [vote/](${REPO_URL}/tree/main/vote) | [Dockerfile.vote](${REPO_URL}/blob/main/.opsera-voting01/Dockerfiles/Dockerfile.vote) | Web UI for casting votes |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ“Š Result | Node.js 18 | [result/](${REPO_URL}/tree/main/result) | [Dockerfile.result](${REPO_URL}/blob/main/.opsera-voting01/Dockerfiles/Dockerfile.result) | Real-time results dashboard |" >> $GITHUB_STEP_SUMMARY
          echo "| âš™ï¸ Worker | .NET 7 | [worker/](${REPO_URL}/tree/main/worker) | [Dockerfile.worker](${REPO_URL}/blob/main/.opsera-voting01/Dockerfiles/Dockerfile.worker) | Background vote processor |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ArgoCD Architecture
        env:
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ğŸ”„ ArgoCD GitOps Architecture

          ### Hub-Spoke Cluster Topology

          ```mermaid
          flowchart TB
              subgraph GITHUB["GitHub (Source of Truth)"]
                  REPO["ğŸ“¦ enterprise-voting-demo-only<br/>Branch: main"]
                  subgraph OVERLAYS["Kustomize Overlays"]
                      O_DEV["overlays/dev/"]
                      O_QA["overlays/qa/"]
                      O_STG["overlays/staging/"]
                      O_UAT["overlays/uat/"]
                      O_MOCK1["overlays/mock1/"]
                  end
              end

              subgraph HUB_CLUSTER["ğŸ¯ Hub Cluster: argocd-usw2"]
                  ARGOCD["ArgoCD Server<br/>namespace: argocd"]
                  subgraph ARGO_APPS["ArgoCD Applications"]
                      APP_DEV["voting01-dev"]
                      APP_QA["voting01-qa"]
                      APP_STG["voting01-staging"]
                      APP_UAT["voting01-uat"]
                      APP_MOCK1["voting01-mock1"]
                  end
              end

              subgraph SPOKE_CLUSTER["ğŸ¡ Spoke Cluster: opsera-usw2-np"]
                  subgraph NS_DEV["voting01-dev"]
                      DEV_VOTE["vote"] & DEV_RESULT["result"] & DEV_WORKER["worker"]
                  end
                  subgraph NS_QA["voting01-qa"]
                      QA_VOTE["vote"] & QA_RESULT["result"] & QA_WORKER["worker"]
                  end
                  subgraph NS_STG["voting01-staging"]
                      STG_VOTE["vote"] & STG_RESULT["result"] & STG_WORKER["worker"]
                  end
                  subgraph NS_UAT["voting01-uat"]
                      UAT_VOTE["vote"] & UAT_RESULT["result"] & UAT_WORKER["worker"]
                  end
                  subgraph NS_MOCK1["voting01-mock1"]
                      M1_VOTE["vote"] & M1_RESULT["result"] & M1_WORKER["worker"]
                  end
              end

              REPO -->|"watch"| ARGOCD
              APP_DEV -->|"sync"| NS_DEV
              APP_QA -->|"sync"| NS_QA
              APP_STG -->|"sync"| NS_STG
              APP_UAT -->|"sync"| NS_UAT
              APP_MOCK1 -->|"sync"| NS_MOCK1
              O_DEV -.-> APP_DEV
              O_QA -.-> APP_QA
              O_STG -.-> APP_STG
              O_UAT -.-> APP_UAT
              O_MOCK1 -.-> APP_MOCK1
          ```

          ### ArgoCD GitOps Sync Flow

          ```mermaid
          sequenceDiagram
              participant DEV as Developer
              participant GH as GitHub
              participant CI as GitHub Actions
              participant ARGO as ArgoCD (Hub)
              participant K8S as EKS Spoke

              DEV->>GH: Push code to main
              GH->>CI: Trigger CI workflow
              CI->>CI: Build & scan images
              CI->>CI: Push to ECR
              CI->>GH: Update kustomization.yaml<br/>(newTag: sha-timestamp)
              CI->>ARGO: kubectl annotate refresh=hard
              ARGO->>GH: Detect manifest change
              ARGO->>K8S: Apply via destination.name
              K8S->>K8S: Rolling/Canary/Blue-Green update
              ARGO->>ARGO: Health check & sync status
          ```

          ### ArgoCD Application Configuration

          | Application | Namespace | Source Path | Destination Cluster | Sync Policy | Strategy |
          |-------------|-----------|-------------|--------------------|-|----------|
          | `voting01-dev` | `voting01-dev` | `.opsera-voting01/k8s/overlays/dev` | `opsera-usw2-np` | Auto (prune + selfHeal) | Rolling |
          | `voting01-qa` | `voting01-qa` | `.opsera-voting01/k8s/overlays/qa` | `opsera-usw2-np` | Auto (prune + selfHeal) | Canary |
          | `voting01-staging` | `voting01-staging` | `.opsera-voting01/k8s/overlays/staging` | `opsera-usw2-np` | Auto (prune + selfHeal) | Blue-Green |
          | `voting01-uat` | `voting01-uat` | `.opsera-voting01/k8s/overlays/uat` | `opsera-usw2-np` | Auto (prune + selfHeal) | Canary |
          | `voting01-mock1` | `voting01-mock1` | `.opsera-voting01/k8s/overlays/mock1` | `opsera-usw2-np` | Auto (prune + selfHeal) | Rolling |

          > **Key Design Decision (RULE 59):** ArgoCD uses `destination.name: opsera-usw2-np` (not `destination.server`) for hub-spoke architecture. This references the cluster name registered in ArgoCD, enabling portable configurations.

          ### ArgoCD Sync Options

          | Option | Value | Purpose |
          |--------|-------|---------|
          | `automated.prune` | `true` | Remove orphaned resources |
          | `automated.selfHeal` | `true` | Revert manual drift |
          | `CreateNamespace` | `true` | Auto-create target namespace |
          | `PrunePropagationPolicy` | `foreground` | Wait for child resources |
          | `retry.limit` | `5` | Retry failed syncs |
          | `retry.backoff` | `5s / factor:2 / max:3m` | Exponential backoff |

          EOF

      - name: Kubernetes Architecture
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## â˜¸ï¸ Kubernetes Architecture

          ### Cluster Topology

          ```mermaid
          flowchart TB
              subgraph AWS_REGION["AWS us-west-2"]
                  subgraph VPC["VPC"]
                      subgraph HUB["ğŸ¯ Hub Cluster: argocd-usw2"]
                          ARGO_NS["namespace: argocd<br/>ArgoCD Server + Repo Server + App Controller"]
                      end

                      subgraph SPOKE["ğŸ¡ Spoke Cluster: opsera-usw2-np"]
                          subgraph DEV_NS["namespace: voting01-dev"]
                              D_DEPLOY["Deployments (3)"]
                              D_SVC["Services (2)"]
                              D_ING["Ingress"]
                              D_CM["ConfigMap"]
                              D_SA["ServiceAccounts (3)"]
                          end
                          subgraph QA_NS["namespace: voting01-qa"]
                              Q_ROLL["Rollouts (2) + Deployment (1)"]
                              Q_SVC["Services (2+2 canary)"]
                              Q_ING["Ingress"]
                              Q_AT["AnalysisTemplate"]
                          end
                          subgraph STG_NS["namespace: voting01-staging"]
                              S_ROLL["Rollouts (2) + Deployment (1)"]
                              S_SVC["Services (2+2 preview)"]
                              S_ING["Ingress (active+preview)"]
                          end
                          subgraph UAT_NS["namespace: voting01-uat"]
                              U_ROLL["Rollouts (2) + Deployment (1)"]
                              U_SVC["Services (2+2 canary)"]
                              U_ING["Ingress"]
                              U_AT["AnalysisTemplate"]
                          end
                          subgraph MOCK1_NS["namespace: voting01-mock1"]
                              M_DEPLOY["Deployments (3)"]
                              M_SVC["Services (2)"]
                              M_ING["Ingress"]
                              M_CM["ConfigMap"]
                          end
                      end
                  end

                  ECR["ğŸ³ ECR Registry<br/>792373136340.dkr.ecr.us-west-2.amazonaws.com"]
                  RDS[("ğŸ˜ RDS PostgreSQL")]
                  ELASTICACHE[("ğŸ”´ ElastiCache Redis")]
              end

              SPOKE -.->|"pull images"| ECR
              DEV_NS & QA_NS & STG_NS & UAT_NS & MOCK1_NS -.-> RDS & ELASTICACHE
          ```

          ### Per-Environment Kubernetes Resources

          | Resource | DEV | QA | Staging | UAT | Mock1 |
          |----------|-----|-----|---------|-----|-------|
          | **Namespace** | `voting01-dev` | `voting01-qa` | `voting01-staging` | `voting01-uat` | `voting01-mock1` |
          | **Vote** | Deployment (1 replica) | Rollout (Canary) | Rollout (Blue-Green) | Rollout (Canary) | Deployment (1 replica) |
          | **Result** | Deployment (1 replica) | Rollout (Canary) | Rollout (Blue-Green) | Rollout (Canary) | Deployment (1 replica) |
          | **Worker** | Deployment (1 replica) | Deployment (1 replica) | Deployment (1 replica) | Deployment (1 replica) | Deployment (1 replica) |
          | **Services** | 2 (ClusterIP) | 4 (active + canary) | 4 (active + preview) | 4 (active + canary) | 2 (ClusterIP) |
          | **Ingress** | NGINX (HTTP) | NGINX (HTTP) | NGINX (active + preview) | NGINX (HTTP) | NGINX (HTTP) |
          | **ConfigMap** | `voting01-config` | `voting01-config` | `voting01-config` | `voting01-config` | `voting01-config` |
          | **ServiceAccounts** | 3 (IRSA) | 3 (IRSA) | 3 (IRSA) | 3 (IRSA) | 3 (IRSA) |
          | **Secrets** | `newrelic-license` | `newrelic-license` | `newrelic-license` | `newrelic-license` | `newrelic-license` |
          | **AnalysisTemplate** | - | NR error rate < 2% | - | NR error rate < 2% | - |

          ### Kustomize Overlay Structure

          ```
          .opsera-voting01/k8s/
          â”œâ”€â”€ base/                          # Shared base resources
          â”‚   â”œâ”€â”€ kustomization.yaml         # Base kustomization
          â”‚   â”œâ”€â”€ namespace.yaml             # Namespace (overridden per env)
          â”‚   â”œâ”€â”€ vote-deployment.yaml       # Vote Deployment template
          â”‚   â”œâ”€â”€ vote-service.yaml          # Vote ClusterIP Service
          â”‚   â”œâ”€â”€ result-deployment.yaml     # Result Deployment template
          â”‚   â”œâ”€â”€ result-service.yaml        # Result ClusterIP Service
          â”‚   â”œâ”€â”€ worker-deployment.yaml     # Worker Deployment template
          â”‚   â””â”€â”€ ingress.yaml              # NGINX Ingress template
          â””â”€â”€ overlays/
              â”œâ”€â”€ dev/                       # Rolling deployment
              â”‚   â”œâ”€â”€ kustomization.yaml     # namespace, images, patches
              â”‚   â”œâ”€â”€ configmap.yaml         # DEV-specific config
              â”‚   â””â”€â”€ serviceaccounts.yaml   # IRSA roles
              â”œâ”€â”€ qa/                        # Canary with NR analysis
              â”‚   â”œâ”€â”€ kustomization.yaml
              â”‚   â”œâ”€â”€ configmap.yaml
              â”‚   â”œâ”€â”€ serviceaccounts.yaml
              â”‚   â”œâ”€â”€ rollout.yaml           # Argo Rollout (Canary)
              â”‚   â””â”€â”€ analysis-template.yaml # NR error rate check
              â”œâ”€â”€ staging/                   # Blue-Green with preview
              â”‚   â”œâ”€â”€ kustomization.yaml
              â”‚   â”œâ”€â”€ configmap.yaml
              â”‚   â”œâ”€â”€ serviceaccounts.yaml
              â”‚   â””â”€â”€ rollout.yaml           # Argo Rollout (Blue-Green)
              â”œâ”€â”€ uat/                       # Canary with NR analysis
              â”‚   â”œâ”€â”€ kustomization.yaml
              â”‚   â”œâ”€â”€ configmap.yaml
              â”‚   â”œâ”€â”€ serviceaccounts.yaml
              â”‚   â”œâ”€â”€ rollout.yaml
              â”‚   â””â”€â”€ analysis-template.yaml
              â””â”€â”€ mock1/                     # Rolling deployment
                  â”œâ”€â”€ kustomization.yaml
                  â”œâ”€â”€ configmap.yaml
                  â””â”€â”€ serviceaccounts.yaml
          ```

          ### Deployment Strategies Deep Dive

          ```mermaid
          flowchart LR
              subgraph ROLLING["Rolling (DEV, Mock1)"]
                  R1["Old Pod 1"] -->|"replace"| R2["New Pod 1"]
                  R3["maxUnavailable: 0<br/>maxSurge: 1"]
              end

              subgraph CANARY["Canary (QA, UAT)"]
                  C1["Stable: 100%"] --> C2["Canary: 20%<br/>Stable: 80%"]
                  C2 --> C3["Canary: 50%<br/>Stable: 50%"]
                  C3 --> C4["New: 100%"]
                  C5["ğŸ“Š NR Analysis<br/>Error Rate < 2%"]
                  C2 -.->|"analyze"| C5
                  C5 -.->|"pass"| C3
                  C5 -.->|"fail"| C6["ğŸ”™ Auto-Rollback"]
              end

              subgraph BLUEGREEN["Blue-Green (Staging)"]
                  BG1["ğŸ”µ Active Service"] --> BG2["ğŸŸ¢ Preview Service"]
                  BG2 -->|"manual promote"| BG3["ğŸŸ¢ Becomes Active"]
                  BG4["Preview URL for testing"]
              end
          ```

          ### IRSA (IAM Roles for Service Accounts)

          | Service Account | Environment | IAM Role ARN Pattern |
          |----------------|-------------|---------------------|
          | `vote-sa` | All | `arn:aws:iam::792373136340:role/voting01-{env}-vote-irsa` |
          | `result-sa` | All | `arn:aws:iam::792373136340:role/voting01-{env}-result-irsa` |
          | `worker-sa` | All | `arn:aws:iam::792373136340:role/voting01-{env}-worker-irsa` |

          > IRSA enables pods to assume AWS IAM roles without embedding credentials. Each service account is annotated with `eks.amazonaws.com/role-arn` to access Secrets Manager for database credentials.

          ### Networking & Ingress

          ```mermaid
          flowchart LR
              INTERNET["ğŸŒ Internet"] --> ALB["AWS ALB<br/>*.agent.opsera.dev"]
              ALB --> NGINX["NGINX Ingress Controller<br/>(Spoke Cluster)"]

              NGINX -->|"vote-voting01-dev"| DEV_VOTE["vote:80"]
              NGINX -->|"result-voting01-dev"| DEV_RESULT["result:80"]
              NGINX -->|"vote-voting01-qa"| QA_VOTE["vote:80"]
              NGINX -->|"vote-voting01-mock1"| MOCK1_VOTE["vote:80"]
              NGINX -->|"..."| MORE["other envs"]
          ```

          | Environment | Vote URL | Result URL | Preview URLs |
          |-------------|----------|------------|--------------|
          | DEV | `vote-voting01-dev.agent.opsera.dev` | `result-voting01-dev.agent.opsera.dev` | - |
          | QA | `vote-voting01-qa.agent.opsera.dev` | `result-voting01-qa.agent.opsera.dev` | - |
          | Staging | `vote-voting01-staging.agent.opsera.dev` | `result-voting01-staging.agent.opsera.dev` | `*-preview.agent.opsera.dev` |
          | UAT | `vote-voting01-uat.agent.opsera.dev` | `result-voting01-uat.agent.opsera.dev` | - |
          | Mock1 | `vote-voting01-mock1.agent.opsera.dev` | `result-voting01-mock1.agent.opsera.dev` | - |

          EOF

      - name: Infrastructure Architecture
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ğŸ—ï¸ Infrastructure Architecture

          ```mermaid
          flowchart LR
              subgraph GH["GitHub"]
                  REPO[("ğŸ“¦ Source")]
                  CI["âš™ï¸ Actions"]
              end

              subgraph AWS["AWS us-west-2"]
                  ECR["ğŸ³ ECR"]
                  subgraph EKS["EKS Clusters"]
                      HUB["ğŸ¯ ArgoCD Hub<br/>argocd-usw2"]
                      SPOKE["ğŸ¡ Workloads<br/>opsera-usw2-np"]
                  end
                  RDS[("ğŸ˜ RDS")]
                  REDIS[("ğŸ”´ ElastiCache")]
              end

              subgraph ENVS["Environments (5)"]
                  DEV["ğŸ”§ DEV"]
                  QA["ğŸ§ª QA"]
                  STG["ğŸ­ Staging"]
                  UAT["ğŸ”¬ UAT"]
                  MOCK1["ğŸ§© Mock1"]
              end

              NR["ğŸ“Š New Relic"]

              REPO --> CI --> ECR --> HUB --> SPOKE
              SPOKE --> DEV & QA & STG & UAT & MOCK1
              DEV & QA & STG & UAT & MOCK1 --> NR
              DEV & QA & STG & UAT & MOCK1 -.-> RDS & REDIS
          ```

          EOF

      - name: CI/CD Pipeline Flow
        env:
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          cat << 'MERMAID' >> $GITHUB_STEP_SUMMARY
          ## ğŸ”„ CI/CD Pipeline Flow

          ### DEV Pipeline (Auto-trigger on push)
          ```mermaid
          flowchart LR
              subgraph TRIGGER["Trigger"]
                  PUSH["ğŸ“¥ Push to main"]
              end

              subgraph SCAN["Security & Quality"]
                  SEC["ğŸ”’ Gitleaks<br/>Secret Scan"]
                  SONAR["ğŸ“Š SonarQube<br/>Code Quality"]
              end

              subgraph BUILD["Build & Scan"]
                  B1["ğŸ—ï¸ Build Vote"]
                  B2["ğŸ—ï¸ Build Result"]
                  B3["ğŸ—ï¸ Build Worker"]
                  G1["ğŸ›¡ï¸ Grype Scan"]
              end

              subgraph DEPLOY["Deploy"]
                  ECR["ğŸ“¦ Push ECR"]
                  KUST["ğŸ“ Update Kustomize"]
                  ARGO["ğŸ”„ ArgoCD Sync"]
              end

              subgraph NOTIFY["Notifications"]
                  SLACK["ğŸ“¢ Slack"]
                  JIRA["ğŸ“‹ Jira"]
              end

              PUSH --> SEC & SONAR
              SEC & SONAR --> B1 & B2 & B3
              B1 & B2 & B3 --> G1
              G1 --> ECR --> KUST --> ARGO
              ARGO --> SLACK & JIRA
          ```

          ### Environment Promotion
          ```mermaid
          flowchart LR
              subgraph DEV["ğŸ”§ DEV Environment"]
                  D1["CI Build DEV"]
                  D2["Rolling Deploy"]
              end

              subgraph QA["ğŸ§ª QA Environment"]
                  Q1["CI Build QA"]
                  Q2["ğŸ¤ Canary Deploy<br/>20% â†’ 50% â†’ 100%"]
                  Q3["APM Analysis"]
              end

              subgraph STG["ğŸ­ Staging Environment"]
                  S1["CI Build Staging"]
                  S2["ğŸ”µğŸŸ¢ Blue-Green<br/>Preview URL"]
                  S3["Traffic Switch"]
              end

              subgraph UAT_ENV["ğŸ”¬ UAT Environment"]
                  U1["CI Build UAT"]
                  U2["ğŸ¤ Canary Deploy"]
                  U3["APM Analysis"]
              end

              subgraph MOCK1_ENV["ğŸ§© MOCK1 Environment"]
                  M1["CI Build Mock1"]
                  M2["Rolling Deploy"]
              end

              D1 --> D2
              D2 -->|"Manual Promote"| Q1
              Q1 --> Q2 --> Q3
              Q3 -->|"Approval Gate"| S1
              S1 --> S2 --> S3
              S3 -->|"Approve"| U1
              U1 --> U2 --> U3
              D2 -->|"Manual"| M1
              M1 --> M2
          ```

          ### Workflow Files
          MERMAID
          echo "| Pipeline | File | Trigger | Strategy |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|------|---------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| DEV CI/CD | [ci-build-push-voting01-dev.yaml](${REPO_URL}/blob/main/.github/workflows/ci-build-push-voting01-dev.yaml) | Push to main | Rolling |" >> $GITHUB_STEP_SUMMARY
          echo "| QA CI/CD | [ci-build-push-voting01-qa.yaml](${REPO_URL}/blob/main/.github/workflows/ci-build-push-voting01-qa.yaml) | Manual / Dispatch | Canary |" >> $GITHUB_STEP_SUMMARY
          echo "| Staging CI/CD | [ci-build-push-voting01-staging.yaml](${REPO_URL}/blob/main/.github/workflows/ci-build-push-voting01-staging.yaml) | Manual / Dispatch | Blue-Green |" >> $GITHUB_STEP_SUMMARY
          echo "| UAT CI/CD | [ci-build-push-voting01-uat.yaml](${REPO_URL}/blob/main/.github/workflows/ci-build-push-voting01-uat.yaml) | Manual / Dispatch | Canary |" >> $GITHUB_STEP_SUMMARY
          echo "| Mock1 CI/CD | [ci-build-push-voting01-mock1.yaml](${REPO_URL}/blob/main/.github/workflows/ci-build-push-voting01-mock1.yaml) | Manual / Dispatch | Rolling |" >> $GITHUB_STEP_SUMMARY
          echo "| Promotion | [promote-voting01.yaml](${REPO_URL}/blob/main/.github/workflows/promote-voting01.yaml) | Manual | Health Check + Dispatch |" >> $GITHUB_STEP_SUMMARY
          echo "| Bootstrap | [00-bootstrap-infrastructure-voting01.yaml](${REPO_URL}/blob/main/.github/workflows/00-bootstrap-infrastructure-voting01.yaml) | Manual | Terraform + ArgoCD |" >> $GITHUB_STEP_SUMMARY
          echo "| Landscape | [deployment-landscape-voting01.yaml](${REPO_URL}/blob/main/.github/workflows/deployment-landscape-voting01.yaml) | Schedule / Push | Report Only |" >> $GITHUB_STEP_SUMMARY
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY

          ### Pipeline Jobs Detail
          | Job | Purpose | Blocking | Outputs |
          |-----|---------|----------|---------|
          | ğŸ”’ Security Scan | Gitleaks secret detection | configurable | - |
          | ğŸ“Š SonarQube | Code quality analysis | configurable | quality_gate_status |
          | ğŸ—ï¸ Build & Push | Docker build + Grype scan + ECR push | yes | image_tag, vulnerabilities |
          | ğŸš€ Deploy | Kustomize update + ArgoCD sync | yes | success status |
          | ğŸ“¢ Slack | Pipeline notifications | no | - |
          | ğŸ“‹ Jira | Issue creation on failure | no | issue_key |

          EOF

      - name: Environment Status Table
        env:
          DEV_V: ${{ needs.collect-data.outputs.dev_version }}
          QA_V: ${{ needs.collect-data.outputs.qa_version }}
          STG_V: ${{ needs.collect-data.outputs.staging_version }}
          UAT_V: ${{ needs.collect-data.outputs.uat_version }}
          MOCK1_V: ${{ needs.collect-data.outputs.mock1_version }}
          SBX1_V: ${{ needs.collect-data.outputs.sbx1_version }}
          DEV_P: ${{ needs.collect-metrics.outputs.dev_pods }}
          QA_P: ${{ needs.collect-metrics.outputs.qa_pods }}
          STG_P: ${{ needs.collect-metrics.outputs.staging_pods }}
          UAT_P: ${{ needs.collect-metrics.outputs.uat_pods }}
          MOCK1_P: ${{ needs.collect-metrics.outputs.mock1_pods }}
          SBX1_P: ${{ needs.collect-metrics.outputs.sbx1_pods }}
          DEV_H: ${{ needs.collect-metrics.outputs.dev_health }}
          QA_H: ${{ needs.collect-metrics.outputs.qa_health }}
          STG_H: ${{ needs.collect-metrics.outputs.staging_health }}
          UAT_H: ${{ needs.collect-metrics.outputs.uat_health }}
          MOCK1_H: ${{ needs.collect-metrics.outputs.mock1_health }}
          SBX1_H: ${{ needs.collect-metrics.outputs.sbx1_health }}
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          health_icon() {
            case "$1" in
              healthy) echo "âœ…" ;;
              degraded) echo "âš ï¸" ;;
              *) echo "â“" ;;
            esac
          }

          # Extract commit SHA from version (format: commitsha-timestamp)
          version_link() {
            local version=$1
            if [ "$version" != "unknown" ] && [ -n "$version" ]; then
              local sha=$(echo "$version" | cut -d'-' -f1)
              echo "[\`${version}\`](${REPO_URL}/commit/${sha})"
            else
              echo "\`${version}\`"
            fi
          }

          echo "## ğŸŒ Environment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | Version | Pods | Health | Strategy | ArgoCD App |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|---------|------|--------|----------|------------|" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ”§ **DEV** | $(version_link "$DEV_V") | ${DEV_P:-0} | $(health_icon $DEV_H) | Rolling | \`voting01-dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ§ª **QA** | $(version_link "$QA_V") | ${QA_P:-0} | $(health_icon $QA_H) | ğŸ¤ Canary | \`voting01-qa\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ­ **STAGING** | $(version_link "$STG_V") | ${STG_P:-0} | $(health_icon $STG_H) | ğŸ”µğŸŸ¢ Blue-Green | \`voting01-staging\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ”¬ **UAT** | $(version_link "$UAT_V") | ${UAT_P:-0} | $(health_icon $UAT_H) | ğŸ¤ Canary | \`voting01-uat\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ§© **MOCK1** | $(version_link "$MOCK1_V") | ${MOCK1_P:-0} | $(health_icon $MOCK1_H) | Rolling | \`voting01-mock1\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ–ï¸ **SBX1** | $(version_link "$SBX1_V") | ${SBX1_P:-0} | $(health_icon $SBX1_H) | Rolling | \`voting01-sbx1\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Deployment History
        env:
          DEV_HIST: ${{ needs.collect-data.outputs.dev_history }}
          QA_HIST: ${{ needs.collect-data.outputs.qa_history }}
          STG_HIST: ${{ needs.collect-data.outputs.staging_history }}
          UAT_HIST: ${{ needs.collect-data.outputs.uat_history }}
          MOCK1_HIST: ${{ needs.collect-data.outputs.mock1_history }}
          SBX1_HIST: ${{ needs.collect-data.outputs.sbx1_history }}
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary><strong>ğŸ“œ Deployment History (Last 5 per environment)</strong></summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Function to convert timestamp to relative time
          relative_time() {
            local timestamp=$1
            local now=$(date +%s)
            local diff=$((now - timestamp))

            if [ $diff -lt 60 ]; then
              echo "just now"
            elif [ $diff -lt 3600 ]; then
              local mins=$((diff / 60))
              [ $mins -eq 1 ] && echo "1 min ago" || echo "${mins} mins ago"
            elif [ $diff -lt 86400 ]; then
              local hrs=$((diff / 3600))
              local remaining_mins=$(((diff % 3600) / 60))
              if [ $remaining_mins -gt 0 ]; then
                echo "${hrs}h ${remaining_mins}m ago"
              else
                [ $hrs -eq 1 ] && echo "1 hr ago" || echo "${hrs} hrs ago"
              fi
            elif [ $diff -lt 604800 ]; then
              local days=$((diff / 86400))
              [ $days -eq 1 ] && echo "1 day ago" || echo "${days} days ago"
            else
              local weeks=$((diff / 604800))
              [ $weeks -eq 1 ] && echo "1 week ago" || echo "${weeks} weeks ago"
            fi
          }

          # Function to render deployment history table
          # Format: SHA~TAG~TIMESTAMP~AUTHOR
          render_history() {
            local env_name=$1
            local env_icon=$2
            local history=$3

            echo "#### ${env_icon} ${env_name}" >> $GITHUB_STEP_SUMMARY
            echo "| # | Commit | Image Tag | Deployed By | When |" >> $GITHUB_STEP_SUMMARY
            echo "|---|--------|-----------|-------------|------|" >> $GITHUB_STEP_SUMMARY

            if [ -z "$history" ]; then
              echo "| - | No deployments found | - | - | - |" >> $GITHUB_STEP_SUMMARY
            else
              count=1
              IFS=';' read -ra ENTRIES <<< "$history"
              for entry in "${ENTRIES[@]}"; do
                if [ -n "$entry" ]; then
                  SHA=$(echo "$entry" | cut -d'~' -f1)
                  TAG=$(echo "$entry" | cut -d'~' -f2)
                  TIMESTAMP=$(echo "$entry" | cut -d'~' -f3)
                  AUTHOR=$(echo "$entry" | cut -d'~' -f4)
                  REL_TIME=$(relative_time "$TIMESTAMP")
                  echo "| ${count} | [\`${SHA}\`](${REPO_URL}/commit/${SHA}) | \`${TAG}\` | ${AUTHOR} | ${REL_TIME} |" >> $GITHUB_STEP_SUMMARY
                  count=$((count + 1))
                fi
              done
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          }

          render_history "DEV" "ğŸ”§" "$DEV_HIST"
          render_history "QA" "ğŸ§ª" "$QA_HIST"
          render_history "STAGING" "ğŸ­" "$STG_HIST"
          render_history "UAT" "ğŸ”¬" "$UAT_HIST"
          render_history "MOCK1" "ğŸ§©" "$MOCK1_HIST"
          render_history "SBX1" "ğŸ–ï¸" "$SBX1_HIST"

          echo "</details>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Quick Links
        env:
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ğŸ”— Quick Links

          ### ğŸ”§ Kubernetes Manifests
          EOF
          echo "| Environment | Kustomization | ConfigMap | Deployment Base |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|---------------|-----------|-----------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Base | [k8s/base](${REPO_URL}/tree/main/.opsera-voting01/k8s/base) | - | [vote](${REPO_URL}/blob/main/.opsera-voting01/k8s/base/vote-deployment.yaml) / [result](${REPO_URL}/blob/main/.opsera-voting01/k8s/base/result-deployment.yaml) / [worker](${REPO_URL}/blob/main/.opsera-voting01/k8s/base/worker-deployment.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| DEV | [overlays/dev](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/dev) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/dev/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/dev/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| QA | [overlays/qa](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/qa) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/qa/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/qa/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| Staging | [overlays/staging](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/staging) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/staging/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/staging/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| UAT | [overlays/uat](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/uat) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/uat/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/uat/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| Mock1 | [overlays/mock1](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/mock1) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/mock1/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/mock1/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| SBX1 | [overlays/sbx1](${REPO_URL}/tree/main/.opsera-voting01/k8s/overlays/sbx1) | [configmap](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/sbx1/configmap.yaml) | [kustomization](${REPO_URL}/blob/main/.opsera-voting01/k8s/overlays/sbx1/kustomization.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### â–¶ï¸ Run Workflows" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Link |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ”§ Deploy to DEV | [â–¶ï¸ Run CI Build DEV](${REPO_URL}/actions/workflows/ci-build-push-voting01-dev.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ§ª Deploy to QA | [â–¶ï¸ Run CI Build QA](${REPO_URL}/actions/workflows/ci-build-push-voting01-qa.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ­ Deploy to Staging | [â–¶ï¸ Run CI Build Staging](${REPO_URL}/actions/workflows/ci-build-push-voting01-staging.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ”¬ Deploy to UAT | [â–¶ï¸ Run CI Build UAT](${REPO_URL}/actions/workflows/ci-build-push-voting01-uat.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ§© Deploy to Mock1 | [â–¶ï¸ Run CI Build Mock1](${REPO_URL}/actions/workflows/ci-build-push-voting01-mock1.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ–ï¸ Deploy to SBX1 | [â–¶ï¸ Run CI Build SBX1](${REPO_URL}/actions/workflows/ci-build-push-voting01-sbx1.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| â¬†ï¸ Promote Environment | [â–¶ï¸ Run Promotion](${REPO_URL}/actions/workflows/promote-voting01.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ” Run Diagnostics | [â–¶ï¸ Run Diagnostics](${REPO_URL}/actions/workflows/diagnostics-voting01.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ“Š Refresh Landscape | [â–¶ï¸ Run Landscape](${REPO_URL}/actions/workflows/deployment-landscape-voting01.yaml) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Live Endpoints
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ### ğŸŒ Live Endpoints
          | Environment | Vote App | Result App |
          |-------------|----------|------------|
          | ğŸ”§ DEV | [vote-voting01-dev.agent.opsera.dev](https://vote-voting01-dev.agent.opsera.dev) | [result-voting01-dev.agent.opsera.dev](https://result-voting01-dev.agent.opsera.dev) |
          | ğŸ§ª QA | [vote-voting01-qa.agent.opsera.dev](https://vote-voting01-qa.agent.opsera.dev) | [result-voting01-qa.agent.opsera.dev](https://result-voting01-qa.agent.opsera.dev) |
          | ğŸ­ Staging | [vote-voting01-staging.agent.opsera.dev](https://vote-voting01-staging.agent.opsera.dev) | [result-voting01-staging.agent.opsera.dev](https://result-voting01-staging.agent.opsera.dev) |
          | ğŸ”¬ UAT | [vote-voting01-uat.agent.opsera.dev](https://vote-voting01-uat.agent.opsera.dev) | [result-voting01-uat.agent.opsera.dev](https://result-voting01-uat.agent.opsera.dev) |
          | ğŸ§© Mock1 | [vote-voting01-mock1.agent.opsera.dev](https://vote-voting01-mock1.agent.opsera.dev) | [result-voting01-mock1.agent.opsera.dev](https://result-voting01-mock1.agent.opsera.dev) |
          | ğŸ–ï¸ SBX1 | [vote-voting01-sbx1.agent.opsera.dev](https://vote-voting01-sbx1.agent.opsera.dev) | [result-voting01-sbx1.agent.opsera.dev](https://result-voting01-sbx1.agent.opsera.dev) |

          EOF

      - name: Observability
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ğŸ“Š Observability

          ### New Relic APM
          | Environment | Vote | Result | Worker |
          |-------------|------|--------|--------|
          | DEV | voting01-vote-dev | voting01-result-dev | voting01-worker-dev |
          | QA | voting01-vote-qa | voting01-result-qa | voting01-worker-qa |
          | Staging | voting01-vote-staging | voting01-result-staging | voting01-worker-staging |
          | UAT | voting01-vote-uat | voting01-result-uat | voting01-worker-uat |
          | Mock1 | voting01-vote-mock1 | voting01-result-mock1 | voting01-worker-mock1 |

          ğŸ”— [Open New Relic Dashboard](https://one.newrelic.com)

          EOF

      - name: Infrastructure
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## â˜ï¸ Infrastructure

          | Resource | Details | Console |
          |----------|---------|---------|
          | ğŸ³ ECR Registry | `792373136340.dkr.ecr.us-west-2.amazonaws.com/opsera/` | [AWS Console](https://us-west-2.console.aws.amazon.com/ecr/repositories?region=us-west-2) |
          | ğŸ¯ Hub Cluster | `argocd-usw2` | [EKS Console](https://us-west-2.console.aws.amazon.com/eks/home?region=us-west-2#/clusters/argocd-usw2) |
          | ğŸ¡ Spoke Cluster | `opsera-usw2-np` | [EKS Console](https://us-west-2.console.aws.amazon.com/eks/home?region=us-west-2#/clusters/opsera-usw2-np) |
          | ğŸ”„ ArgoCD | GitOps Controller | [ArgoCD Dashboard](https://argocd.agent.opsera.dev) |

          EOF

      - name: Promotion Flow
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ğŸš€ Promotion Flow

          ```mermaid
          flowchart LR
              DEV["ğŸ”§ DEV<br/>Auto-deploy on push<br/>Rolling"]
              QA["ğŸ§ª QA<br/>Manual trigger<br/>ğŸ¤ Canary 20â†’50â†’100%"]
              STG["ğŸ­ STAGING<br/>Approval required<br/>ğŸ”µğŸŸ¢ Blue-Green"]
              UAT["ğŸ”¬ UAT<br/>Manual trigger<br/>ğŸ¤ Canary 20â†’50â†’100%"]
              MOCK1["ğŸ§© MOCK1<br/>Manual trigger<br/>Rolling"]
              PROD["ğŸ­ PRODUCTION<br/>Coming Soon"]

              DEV -->|"promote"| QA -->|"approve"| STG -->|"approve"| UAT -.->|"future"| PROD
              DEV -->|"manual"| MOCK1
          ```

          EOF

      - name: Report Footer
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ---

          <div align="center">

          **Powered by [Opsera](https://opsera.io)** - The Unified DevOps Platform

          ğŸ“… Generated: $(date -u +'%Y-%m-%d %H:%M UTC') | [ğŸ”„ Refresh](https://github.com/${{ env.GITHUB_REPO }}/actions/workflows/deployment-landscape-voting01.yaml)

          </div>
          EOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE README
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  update-readme:
    name: "ğŸ“ Update README"
    needs: [collect-data, collect-metrics, generate-report]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update README with Deployment Status
        env:
          DEV_HIST: ${{ needs.collect-data.outputs.dev_history }}
          QA_HIST: ${{ needs.collect-data.outputs.qa_history }}
          STG_HIST: ${{ needs.collect-data.outputs.staging_history }}
          REPO_URL: https://github.com/${{ env.GITHUB_REPO }}
        run: |
          # Function to convert timestamp to relative time
          relative_time() {
            local timestamp=$1
            local now=$(date +%s)
            local diff=$((now - timestamp))

            if [ $diff -lt 60 ]; then
              echo "just now"
            elif [ $diff -lt 3600 ]; then
              local mins=$((diff / 60))
              [ $mins -eq 1 ] && echo "1 min ago" || echo "${mins} mins ago"
            elif [ $diff -lt 86400 ]; then
              local hrs=$((diff / 3600))
              local remaining_mins=$(((diff % 3600) / 60))
              if [ $remaining_mins -gt 0 ]; then
                echo "${hrs}h ${remaining_mins}m ago"
              else
                [ $hrs -eq 1 ] && echo "1 hr ago" || echo "${hrs} hrs ago"
              fi
            elif [ $diff -lt 604800 ]; then
              local days=$((diff / 86400))
              [ $days -eq 1 ] && echo "1 day ago" || echo "${days} days ago"
            else
              local weeks=$((diff / 604800))
              [ $weeks -eq 1 ] && echo "1 week ago" || echo "${weeks} weeks ago"
            fi
          }

          # Function to get deployment info
          get_deploy_info() {
            local history=$1
            if [ -z "$history" ]; then
              echo "-|-|_No deployments_"
              return
            fi

            # Get latest entry
            LATEST=$(echo "$history" | cut -d';' -f1)
            TIMESTAMP=$(echo "$LATEST" | cut -d'~' -f3)
            AUTHOR=$(echo "$LATEST" | cut -d'~' -f4)
            REL_TIME=$(relative_time "$TIMESTAMP")

            # Get last 5 as bullets with author names
            BULLETS=""
            IFS=';' read -ra ENTRIES <<< "$history"
            count=0
            for entry in "${ENTRIES[@]}"; do
              if [ -n "$entry" ] && [ $count -lt 5 ]; then
                TAG=$(echo "$entry" | cut -d'~' -f2)
                SHORT_TAG=$(echo "$TAG" | cut -c1-12)
                TS=$(echo "$entry" | cut -d'~' -f3)
                ENTRY_AUTHOR=$(echo "$entry" | cut -d'~' -f4)
                RT=$(relative_time "$TS")
                # Shorten author name if too long
                SHORT_AUTHOR=$(echo "$ENTRY_AUTHOR" | cut -c1-15)
                if [ -z "$BULLETS" ]; then
                  BULLETS="â€¢ \`${SHORT_TAG}\` (${RT}) by _${SHORT_AUTHOR}_"
                else
                  BULLETS="${BULLETS}<br>â€¢ \`${SHORT_TAG}\` (${RT}) by _${SHORT_AUTHOR}_"
                fi
                count=$((count + 1))
              fi
            done

            echo "${REL_TIME}|${AUTHOR}|${BULLETS}"
          }

          # Get info for each environment
          DEV_INFO=$(get_deploy_info "$DEV_HIST")
          QA_INFO=$(get_deploy_info "$QA_HIST")
          STG_INFO=$(get_deploy_info "$STG_HIST")

          DEV_TIME=$(echo "$DEV_INFO" | cut -d'|' -f1)
          DEV_OWNER=$(echo "$DEV_INFO" | cut -d'|' -f2)
          DEV_BULLETS=$(echo "$DEV_INFO" | cut -d'|' -f3)

          QA_TIME=$(echo "$QA_INFO" | cut -d'|' -f1)
          QA_OWNER=$(echo "$QA_INFO" | cut -d'|' -f2)
          QA_BULLETS=$(echo "$QA_INFO" | cut -d'|' -f3)

          STG_TIME=$(echo "$STG_INFO" | cut -d'|' -f1)
          STG_OWNER=$(echo "$STG_INFO" | cut -d'|' -f2)
          STG_BULLETS=$(echo "$STG_INFO" | cut -d'|' -f3)

          UPDATED_AT=$(date -u +'%Y-%m-%d %H:%M UTC')

          # Create new deployment status section
          cat > /tmp/deploy-status.md << STATUSEOF
          <!-- DEPLOYMENT-STATUS:START - Auto-updated by landscape workflow -->
          | Environment | App | Last Deploy | Owner | Recent Deployments |
          |-------------|-----|-------------|-------|-------------------|
          | ğŸ”§ **DEV** | [Vote](https://vote-voting01-dev.agent.opsera.dev) / [Result](https://result-voting01-dev.agent.opsera.dev) | ${DEV_TIME} | ${DEV_OWNER} | ${DEV_BULLETS} |
          | ğŸ§ª **QA** | [Vote](https://vote-voting01-qa.agent.opsera.dev) / [Result](https://result-voting01-qa.agent.opsera.dev) | ${QA_TIME} | ${QA_OWNER} | ${QA_BULLETS} |
          | ğŸ­ **Staging** | [Vote](https://vote-voting01-staging.agent.opsera.dev) / [Result](https://result-voting01-staging.agent.opsera.dev) | ${STG_TIME} | ${STG_OWNER} | ${STG_BULLETS} |

          > ğŸ“… _Last updated: ${UPDATED_AT}_ | [ğŸ”„ Refresh](https://github.com/${{ env.GITHUB_REPO }}/actions/workflows/deployment-landscape-voting01.yaml)
          <!-- DEPLOYMENT-STATUS:END -->
          STATUSEOF

          # Remove leading whitespace from heredoc
          sed -i 's/^          //' /tmp/deploy-status.md

          # Update README between markers
          awk '
            /<!-- DEPLOYMENT-STATUS:START/ { skip=1; system("cat /tmp/deploy-status.md"); next }
            /<!-- DEPLOYMENT-STATUS:END/ { skip=0; next }
            !skip { print }
          ' README.md > README.md.tmp && mv README.md.tmp README.md

          echo "README updated with deployment status"
          cat README.md | head -30

      - name: Commit README
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add README.md

          if git diff --staged --quiet; then
            echo "No changes to README"
          else
            git commit -m "docs: Update deployment dashboard [skip ci]"
            # Pull any changes before pushing to avoid conflicts
            git pull --rebase origin main || true
            git push
            echo "README updated and pushed"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NOTIFY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  notify:
    name: "ğŸ“¢ Notify"
    needs: [generate-report, update-readme]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Slack Notification
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "Slack webhook not configured, skipping notification"
            exit 0
          fi
          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "ğŸ“Š Deployment Landscape Report Updated",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ğŸ“Š *Deployment Landscape Report* has been updated for `voting01`\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Full Report>"
                  }
                }
              ]
            }' || true
